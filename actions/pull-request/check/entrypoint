#!/bin/bash
set -eu
set -o pipefail

function main() {
  local token repo number botsString

  while [ "${#}" != 0 ]; do
    case "${1}" in
      --token)
        token="${2}"
        shift 2
        ;;

      --repo)
        repo="${2}"
        shift 2
        ;;

      --number)
        number="${2}"
        shift 2
        ;;

      --bots)
        botsString="${2}"
        shift 2
        ;;

      "")
        shift
        ;;

      *)
        echo "unknown argument \"${1}\""
        exit 1
    esac
  done

  if rules::has_human_commits "${token}" "${repo}" "${number}" "${botsString}"; then
    echo "::set-output name=human_commits::true"
    exit 0
  fi
    echo "::set-output name=human_commits::false"
}

function rules::has_human_commits() {
  local token repo number bots humanCommit
  token=${1}
  repo=${2}
  number=${3}
  botsString=${4}

  IFS="," read -r -a bots <<< "${botsString}"

  # this allows us to parse a newline-separated set of names (which might
  # include spaces) that come out of jq and iterate over them without
  # splitting on spaces
  while IFS= read -r author; do
      humanCommit=0
      for bot in "${bots[@]}"; do
        if [[ "${author}" == "${bot}" ]]; then
          humanCommit=1
          break
        fi
      done

      if [[ ${humanCommit} -eq 0 ]]; then
        echo "human committer: " "${author}"
        return 0
      fi
  done < <(curl "https://api.github.com/repos/${repo}/pulls/${number}/commits" \
    --silent \
    --location \
    --header \
    "Authorization: token ${token}" | jq -r '.[] | .commit.author.name, .commit.committer.name')

  return 1
}

main "${@:-}"
